Харківський університет радіоелектроніки
Факультет комп'ютерних наук
Кафедра програмної інженерії


























ЗВІТ
до практичного заняття 2
з дисципліни "Аналіз та рефакторинг коду"
на тему: "Методи рефакторингу коду програмного забезпечення"












Виконав ст. гр ПЗПІ-22-5
Бєлошапка Микита Юрійович


Перевірив
ст. викладач кафедри ПІ
Сокорчук Ігор Петрович






















Харків 2024
________________




1 МЕТА


      Ознайомитися з основним методам рефакторингу коду на основі реальних прикладів з їхніх власних програмних проектів. Студенти повинні навчитися ідентифікувати проблеми в коді та використовувати відповідні методи рефакторингу для покращення його якості.




2 ЗАВДАННЯ
     
     Студент має вибрати три методи рефакторингу коду з книги Мартіна Фаулера «Refactoring. Improving the Design of Existing Code» і застосувати їх на прикладах власного коду. 
   Для кожного методу рефакторингу потрібно:
1. Описати проблему, яку вирішує обраний метод, зокрема недоліки початкового коду, такі як порушення принципів SOLID, технічний борг чи складність читання;
2. Навести код до застосування методу, який демонструє початковий стан проблеми;
3. Показати код після рефакторингу, де обраний метод вирішує проблему;
4. Надати пояснення переваг використаного методу, наприклад, зменшення дублювання коду, покращення його читабельності, зниження рівня зв’язаності або забезпечення кращої підтримки в майбутньому.




3 ХІД РОБОТИ


Метод 1: Extract Method (Виділення методу)
Проблема
Довгі методи у коді можуть бути важкими для розуміння, супроводження та тестування. Якщо метод виконує декілька завдань, це порушує принцип SRP (Single Responsibility Principle). Виникають складнощі, коли потрібно внести зміни лише в одну з частин цього методу — є ризик ненавмисно вплинути на інші.
Код до рефакторингу
public void ProcessOrder(Order order)
{
    Console.WriteLine("Processing order...");
    if (order.TotalPrice > 1000)
    {
        Console.WriteLine("Applying discount...");
        order.TotalPrice *= 0.9;
    }


    Console.WriteLine("Saving order to database...");
    // Симуляція збереження замовлення
    SaveOrder(order);
    Console.WriteLine("Sending notification to customer...");
    // Симуляція надсилання повідомлення
    SendNotification(order.CustomerEmail);
}


У цьому прикладі метод ProcessOrder виконує три завдання:
1. Перевіряє та застосовує знижку до замовлення.
2. Зберігає замовлення у базі даних.
3. Надсилає повідомлення клієнту.
Це порушує SRP, робить метод важким для розуміння і перетестування окремих його частин.
Код після рефакторингу
public void ProcessOrder(Order order)
{
    ApplyDiscountIfNecessary(order);
    SaveOrder(order);
    NotifyCustomer(order.CustomerEmail);
}


private void ApplyDiscountIfNecessary(Order order)
{
    if (order.TotalPrice > 1000)
    {
        Console.WriteLine("Applying discount...");
        order.TotalPrice *= 0.9;
    }
}


private void SaveOrder(Order order)
{
    Console.WriteLine("Saving order to database...");
    // Симуляція збереження замовлення
}


private void NotifyCustomer(string customerEmail)
{
    Console.WriteLine("Sending notification to customer...");
    // Симуляція надсилання повідомлення
}


Переваги
* Покращення читабельності: Кожен метод виконує лише одну логічну задачу, що полегшує розуміння.
* Простота тестування: Окремі частини логіки можна протестувати незалежно одна від одної.
* Легкість змін: Якщо потрібно змінити логіку застосування знижки або спосіб надсилання повідомлень, це можна зробити, не зачіпаючи інші частини.
* Повторне використання: Виділені методи можна використовувати в інших частинах програми, якщо знадобиться.
________________


Метод 2: Replace Temp with Query (Замінити змінну на запит)
Проблема
Використання тимчасових змінних для збереження проміжних результатів ускладнює підтримку коду. Якщо логіка розрахунку змінюється, це може призвести до помилок у різних місцях, де використовуються ці змінні. Крім того, це порушує DRY (Don't Repeat Yourself), якщо ті самі проміжні розрахунки виконуються в кількох частинах програми.
Код до рефакторингу
public double GetDiscountedPrice(Order order)
{
    double basePrice = order.TotalPrice;
    double discount = basePrice > 1000 ? 0.1 : 0.0;
    return basePrice - (basePrice * discount);
}


Тут використовується тимчасова змінна discount для проміжного результату. Якщо логіка розрахунку зміниться, потрібно буде шукати всі місця, де використовується ця змінна, щоб уникнути помилок.
Код після рефакторингу
public double GetDiscountedPrice(Order order)
{
    return order.TotalPrice - (order.TotalPrice * GetDiscount(order));
}


private double GetDiscount(Order order)
{
    return order.TotalPrice > 1000 ? 0.1 : 0.0;
}


Переваги
* Зменшення залежності від проміжних змінних: Уся логіка розрахунків знаходиться в одному методі, що спрощує її зміну.
* Підвищення читабельності: Код став більш лаконічним і зрозумілим.
* Повторне використання логіки: Метод GetDiscount можна використовувати в інших місцях програми.
________________


Метод 3: Introduce Parameter Object (Введення об’єкта параметрів)
Проблема
Метод з великою кількістю параметрів ускладнює його використання, тестування та розширення. Якщо потрібно додати новий параметр, доводиться змінювати всі виклики цього методу, що порушує принцип OCP (Open/Closed Principle).
Код до рефакторингу
public void GenerateInvoice(string customerName, string customerEmail, double orderTotal, DateTime orderDate)
{
    Console.WriteLine($"Invoice for {customerName} ({customerEmail})");
    Console.WriteLine($"Total: {orderTotal}, Date: {orderDate}");
}


У цьому прикладі метод GenerateInvoice приймає 4 параметри. Якщо потрібно додати, наприклад, адресу клієнта, доведеться змінювати всі виклики методу.
Код після рефакторингу
public void GenerateInvoice(OrderDetails orderDetails)
{
    Console.WriteLine($"Invoice for {orderDetails.CustomerName} ({orderDetails.CustomerEmail})");
    Console.WriteLine($"Total: {orderDetails.OrderTotal}, Date: {orderDetails.OrderDate}");
}


public class OrderDetails
{
    public string CustomerName { get; set; }
    public string CustomerEmail { get; set; }
    public double OrderTotal { get; set; }
    public DateTime OrderDate { get; set; }
}


Переваги
* Зменшення кількості параметрів: Замість передачі багатьох параметрів використовується об’єкт, що робить метод більш зрозумілим.
* Простота розширення: Якщо потрібно додати новий параметр, достатньо оновити клас OrderDetails, не змінюючи сигнатури методу.
* Інкапсуляція даних: Усі параметри об’єднані в одному об’єкті, що підвищує логічну зв’язаність даних.
* Читабельність: Виклики методу стали простішими та зрозумілішими.
________________


Висновки: Кожен із цих методів рефакторингу допомагає вирішити конкретні проблеми коду, роблячи його більш зрозумілим, підтримуваним і відповідним принципам SOLID.